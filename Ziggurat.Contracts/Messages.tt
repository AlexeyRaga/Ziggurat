<#@ template  debug="true" hostSpecific="true" #>
<#@ include file="MultipleOutputHelper.ttinclude" #> 
<#@ output extension=".cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Text.RegularExpressions" #>
<# var manager = MultipleFileOutputManager.Create(Host, GenerationEnvironment); #>

<# manager.StartHeader(); #>
// ----------------------------------------------------------------------------------------------------
// This code is generated based on *.dsl file.
// Do not edit this file. Edit *.dls files instead.
// ----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

<# manager.EndBlock(); #>

<#
    var DefRegex = new Regex(@"^let\s+(?<symbol>[?!@#$^&*])\s+=\s*?(?<base>\w+)$", RegexOptions.Compiled);
	var LineRegex = new Regex(@"^\s*(?<name>\w+)\s*(?<type>[?!@#$^&*])\s*(?<params>.*)$", RegexOptions.Compiled);
	var ParamsRegex = new Regex(@"\s*([\w<>_@]+)\s+(\w+)", RegexOptions.Compiled);

	var symbols = new Dictionary<string, string>();
	symbols["?"] = "ICommand";
	symbols["!"] = "IEvent";

	var dslFiles = Directory.GetFiles(Path.GetDirectoryName(Host.ResolvePath(Host.TemplateFile)), "*.dsl");

	foreach(var fileName in dslFiles) {
	    var justName = Path.GetFileNameWithoutExtension(fileName);

		manager.StartNewFile(justName + ".generated.cs");
#>
namespace <#= System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint") #>.<#= justName #>
{
<#

		var lines = File.ReadAllLines(Host.ResolvePath(fileName));

		foreach (var line in lines.Select(x=>x.Trim())) 
		{
			if (String.IsNullOrEmpty(line)) continue;
			if (line.StartsWith("//")) continue;

			var symbolMatch = DefRegex.Match(line);

			if (symbolMatch.Success) {
				symbols[symbolMatch.Groups["symbol"].Value] = symbolMatch.Groups["base"].Value;
				continue;
			} 
			var match = LineRegex.Match(line);

			if (!match.Success) continue;

			var name = match.Groups["name"].Value;
			var typeToken = match.Groups["type"].Value;
			var prmsToken = match.Groups["params"].Value;

			var type = symbols[typeToken];
			var prms = GetParams(ParamsRegex, prmsToken);

			GenerateContract(name, type, prms);
		}
#>
}
<#
		manager.EndBlock();
	}

#>
<# manager.StartFooter(); #>

<# manager.EndBlock(); #>
<# manager.Process(true); #>

<#+ 
	void GenerateContract(string name, string type, IDictionary<string, string> prms) {
#>
	[Serializable, DataContract]
	public sealed partial class <#= name #> : <#= type #>
	{
<#+ var i = 0;
	foreach(var parm in prms) { #>
		[DataMember(Order = <#= i #> )] public <#= parm.Value #> <#= ToPascalCase(parm.Key) #> { get; set; }
<#+ i++;
	} #>

		public <#= name #>() { }
		public <#= name #>(<#= GenerateParamsString(prms) #>)
		{
<#+ foreach(var parm in prms) { #>
			<#=	ToPascalCase(parm.Key) #> = <#= ToCamelCase(parm.Key) #>;
<#+ } #>
		}
	}

<#+
	}
#>


<#+ 

	private static string GenerateParamsString(IDictionary<string, string> parms)
	{
		var pairs = parms
			.Select(x => String.Format("{0} {1}", x.Value, ToCamelCase(x.Key)));
		return string.Join(", ", pairs);
	}

	private static string ToCamelCase(string value)
	{
		return Char.ToLower(value[0]) + value.Substring(1);
	}

	private static string ToPascalCase(string value)
	{
		return Char.ToUpper(value[0]) + value.Substring(1);
	}

	private static IDictionary<string, string> GetParams(Regex paramsRegex, string paramsToken)
	{
		var matches = paramsRegex.Matches(paramsToken);

		return matches
			.Cast<Match>()
			.ToDictionary(x => x.Groups[2].Value, x => x.Groups[1].Value);
	}

	private static string ResolveType(string typeToken)
	{
		switch (typeToken)
		{
			case "?":
				return "ICommand";
			case "!":
				return "IEvent";
		}

		throw new ArgumentException("Invalid token. Expected '?' for command and '!' for event.");
	}
#>


